# 1.CAP
> CAP理论，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。
> - 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
> - 可用性（A）：保证每个请求不管成功或者失败都有响应。
> - 分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。  
> 
> 其中分区容错性是必须的，所以一般只是在C和A之间权衡

# 2.BASE理论
> BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是：  
>
>  **即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。**  
>
> BASE理论是Basically Available(基本可用)，Soft State（软状态）和 Eventually Consistent（最终一致性）三个短语的缩写。

# 3.3C
> - 共识性（Consensus） — 脑裂（split-brain）问题以及选举（quorum）的重要性 
> - 并发性（Concurrency） 
> - 一致性（Consistency）：保证写和读的一致性
> 
> 
# 4.负载均衡方案有哪些
> 按照技术实现分类：
> - DNS负载均衡（修改DNS映射会有时效性） 
> - IP负载均衡（在内核进程完成数据分发，性能好。所有请求都经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽） 
> - 链路层负载均衡（在数据链路层修改mac地址，真实物理集群所有机器的虚拟ip和负载均衡服务器ip地址一致，通过mac地址来负载均衡。性能好，配置复杂）
  负载均衡方案： 
> - LVS：是基于四层的转发（只能做端口转发，不能做基于URL、目录的转发） 
> - HAproxy：是基于四层和七层的转发，是专业的代理服务器 
> - Nginx：是WEB服务器，缓存服务器，又是反向代理服务器，可以做七层的转发
>
>负载均衡算法：轮询、加权、优先级、最少连接(连接)、最快模式(响应)、观察模式(连接+响应)


# 5.分布式锁方案有哪些
>1. 基于数据库的实现方案  
 使用数据库实现分布式锁的方式是通过在数据库中创建一张锁表，锁的名称作为表名，锁的值作为表中的一个字段值。当需要获取锁时，先在锁表中查询是否已经有了该锁，如果没有则插入一条记录并返回成功，否则返回失败。当需要释放锁时，直接删除该锁对应的记录即可。这种方式的优点是实现简单，但是存在数据库连接池等问题，并且容易出现死锁问题。
>
> 
>2. 基于缓存的实现方案（redis setnx 以及 redlock方案）
  使用缓存实现分布式锁的方式是通过利用缓存的原子性操作来实现锁的获取和释放。常见的缓存有Redis、Memcached等。当需要获取锁时，使用缓存的setnx操作，如果返回值为1则表示获取锁成功，否则表示获取锁失败。当需要释放锁时，使用缓存的del操作将锁删除掉。这种方式的优点是速度快、可靠性高，但是需要考虑缓存的可靠性和数据一致性问题。
>
> 
>3. 基于ZooKeeper的实现方案  
  使用ZooKeeper实现分布式锁的方式是通过创建临时节点来实现锁的获取和释放。当需要获取锁时，创建一个临时节点，如果创建成功则表示获取锁成功，否则需要等待，直到该节点被删除。当需要释放锁时，直接删除该临时节点即可。这种方式的优点是能够解决分布式环境下的数据一致性问题，并且能够实现分布式锁的高可用性，但是需要考虑ZooKeeper的可靠性和性能问题。

# 6.怎么保证服务可用性
> - 可用性是指系统在规定时间内可被访问的能力。关注可以提供服务的时间
> - 可用性 = (1 - 年度不可用时间 / 年度总时间) * 100%， 999: 年度不可用时间<9小时，9999:年度不可用时间<53分钟
> - 集群架构
> - 数据备份
> - 容错处理：限流、降级、熔断、
> - 自动化运维：监控&告警(NOC告警)、使用工具快速发现和解决问题，避免人工操作导致的错误和延迟，灰度发布
> - 多活：灾备集群+应急预案、异地多活、同城多活（多机房、多机架、多网络接口等）

# 7.怎么保证服务的可靠性
> - 可靠性是指系统在规定时间内正确执行所需功能的能力。关注功能是否正常
> - 在可用性的基础上，增加以下机制 
>   - 容错处理：重试、自动化测试、Live Testing 
>   - 服务解耦：削峰填谷、功能独立互不影响、快捷发布 
>   - 安全保障：采取安全措施确保系统的安全性，比如防火墙、加密传输、访问控制等。

# 8.怎么保证服务稳定性
> - 稳定性是指系统在规定时间内保持其良好的响应性和各项指标的一致性的能力。关注服务的性能指标是否稳定
> 1. 架构设计上的保证：为了确保系统的稳定性，设计人员在设计时需要认真评估系统的容量和风险点，确保架构具备足够的缓存和容量，并进行相应的容错和恢复机制设计，同时还需要考虑任务调度器和内存管理等方面。 
> 2. 高质量的代码和测试：程序员在实现功能时，需要严格遵循代码开发规范，确保代码可读性、可维护性以及可扩展性，同时要进行充分的单元测试、集成测试、性能测试和系统测试，发现缺陷及时修复。 
> 3. 监控日志和分析：在运行时，系统通过实时地监控、日志记录及时发现故障，并可以快速反应。通过分析日志和监控数据及时了解系统和服务的状态和风险状况，及时采取解决措施。 
> 4. 自动化运维工具：在内部运维环节中，利用自动化运维工具提高运营效率。运维人员可以通过配置好的工具处理不同的情况，降低人工错误的风险，提高系统稳定性。 
> 5. 灰度发布：在发布或升级时使用灰度发布策略，从而最小化对系统的影响并对系统的稳定性进行完整测试。可以在添加或退出功能模块时使用，避免给整个系统带来风险。  
> 
> 总之，通过合理的架构设计、高质量的代码和测试、及时的监控和分析、自动化运维工具以及灰度发布策略等措施，可以显著提高系统的稳定性。同时，不断优化系统和服务，进行长期和持续的评估和改进，也是理想保障稳定性的手段之一。


# 9.怎么保证数据一致性
```azure
- 重试（在出现一致性问题时如果系统的并发或不一致情况较少，可以先使用重试来解决）
- 分布式事务（需加强）
- 2PC（两阶段提交）
- 3PC（三阶段提交）
- TCC 方案（Try、Confirm、Cancel）
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知方案
- DB和MQ之间的一致性（生产者确认机制、消息持久化、消费者手动ACK+幂等消费）
- DB和Redis之间的一致性
- Cache-Aside Pattern（旁路缓存）：读时如果命中缓存，则直接返回数据，未命中缓存则读数据库并更新缓存；写时只写数据库，然后删除缓存。
- 最好是删除缓存而不是更新缓存、写时最好是先操作数据库再操作缓存(否则增加延迟双删机制)、可以增加删除缓存重试机制
- Read/Write Through (读写穿透)：在Cache-Aside的基础上增加一层代理，读时从代理层读取，代理层首先读缓存，如果不存在则读数据库，并更新缓存吗，然后返回数据；写时也是通过代理写数据库，然后写缓存，成功后再返回
- Write behind（异步缓存写入）：与Read/Write模式相似，也是增加一层代理，但代理在更新数据时，只更新缓存，不更新数据库 ，通过批量异步的方式更新数据库
- 分布式事务去保证一致性（性能变低）
- 兜底核对逻辑（自动+手动fix、核对系统、监听DB DRC消息(data replicate center)）

https://xie.infoq.cn/article/c9bd3866ed5f76c555314aefa
https://juejin.cn/post/6996915693811662884
https://segmentfault.com/a/1190000040321750
```

# 10.怎么做高并发

> 1. 垂直伸缩（增加CPU、内存、磁盘）+ 水平伸缩（增加机器）
> 2. 分布式架构（数据与服务分离，集群部署，负载均衡（轮询、随机、最少连接），增加缓存，读写分离，独立的搜索系统，增加CDN，通过消息队列对服务解耦）


# 11.高性能架构优化措施
> 1. 代码优化 
> 2. 架构优化（缓存、消息队列、集群） 
> 3. 基础组件优化（链接池、连接数） 
> 4. 数据中心优化(就近访问原则，需要解决多数据中心数据一致性问题)
> 5. 硬件优化（网卡1GB->10GB, CPU/GPU，内存等） 
> 6. 操作系统优化（huge page优化）、虚拟机优化（GC）
