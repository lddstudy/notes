# 目录
[TOC]

# 0. Go语言设计与实现
> https://draveness.me/golang/

# 1.map的底层实现
>背诵版：  
> 底层是hash表（数组+链表）的方式存储数据。也就是一系列的桶组成的。每个键值对由key的前8位hash值，key，以及value组成，每个桶中保存最多8个键值对。  
> 
> 查询数据时，首先有key hash计算出key属于哪一个桶（用key hash值的末尾B位来定位属于哪一个桶，B是与桶数组长度相关的，2^B=桶数组的长度），找到桶之后，再从链表中开始查找，每个链表节点是一个长度为8的数组，遍历数组，首先对比tophash，然后对比key是否相同，如果相同就返回，不相同就从下一个链表节点继续查找。  
> 
> 数据插入时，用key hash计算属于哪一个桶，然后在链表节点中，找到第一个空位置，将tophash放进去，key-value也放到对应的位置。如果两个hash冲突了，就顺着数组往后放就行了  
> 
> 数据扩容：装载因子>6.5时，开始渐进式扩容。溢出痛非常多时，也会发生扩容
map在扩缩容时，会重新调整数据进行调整，对map元素取地址会有风险，并发访问map也会有异常  
> 
> 原理版：  
https://zhuanlan.zhihu.com/p/495998623
------------------------------------------------------------
# 2.sync.Map的实现原理
> 背诵版：  
> 底层由两个Map存储数据，只读Map和读写Map，读数据时优先从只读Map中读取，如果不存在则从读写Map中获取，从只读Map中读数据时不需要加锁，对读写Map做读写时都需要加锁。另外还有一个misses字段，表示只读Map的命中率，每次降级从读写Map中获取数据，misses就会计数一次，达到一定数量，就回直接将读写Map复制给只读Map，然后读写Map置空，以提高只读Map的命中率。需要注意的是sync.Map只适合读多写少的场景，写多读少的场景sync.Map的性能甚至不如map+mutex。
> 
> 原理版：  
> https://developer.aliyun.com/article/1172753
------------------------------------------------------------
# 3.select的实现原理
> 背诵版：  
每一个 case 对应的 channel 都会被封装到一个结构体中（scase）；  
当第一次执行到 select 时，会锁住所有的 channel 并且，打乱 case 结构体的顺序；  
按照打乱的顺序遍历，如果有就绪的信号，就直接走对应 case 的代码段，之后跳出 select；  
如果没有就绪的代码段，但是有 default 字段，那就走 default 的代码段，之后跳出 select；  
如果没有 default，那就将当前 goroutine 加入所有 channel 的对应等待队列；  
当某一个等待队列就绪时，再次锁住所有的 channel，遍历一遍，将所有等待队列中的 goroutine 取出，之后执行就绪的代码段，跳出select。    
>
> 原理版：  
> https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/
------------------------------------------------------------
# 4.channel的实现原理
> 背诵版：  
> * channel底层是基于一个名为hchan的结构体实现的，hchan内部维护了一个等待发送的协程队列sendq，和一个等待接收的协程队列recvq，如果是有缓冲的channel，还会维护一个环形链表，用来暂存发送到channel的数据。  
> * 当一个协程执行发送时，如果channel中缓冲区已满，或本身就是无缓冲channel，协程会被阻塞，同时 它会被加入到等待发送的协程队列中，等待后续唤醒，
> * 同理当一个协程正在接收数据时，如果channel中没有可用的数据，协程也会被阻塞，同时它会被加入到等待接收的协程队列中，等待后续唤醒。
> * channel数据扭转的逻辑一般是从协程中拷贝到channel的环形链表中，再从环形链表中拷贝到另一个协程中。
> * 这里面有一个巧妙的设计，如果先有一个协程在等待数据，然后才是一个协程发送数据，这种场景下数据不会拷贝到环形链表中，而是直接从发送协程拷贝到接收协程中，节省了内存拷贝操作，提升效率。
>
> 
> * 原理版：  
https://cloud.tencent.com/developer/article/1750350
------------------------------------------------------------
# 5.slice的底层实现 & 容易踩的坑（Todo）
------------------------------------------------------------
# 6.闭包的实现原理（TODO）
------------------------------------------------------------
# 7.GMP模型介绍
> 背诵版：
> * GMP 调度模型是 Go 语言运行时系统（runtime system）的核心组成部分。GMP 调度模型的基本思想是将 goroutine 与线程分离，将多个 goroutine 映射到少量的 OS 线程上，并采用一个调度器（scheduler）来调度线程和 goroutine 的执行。
> * GMP 调度模型的名称来自其三个组成部分：G（goroutine）、M（OS 线程）、P（processor）。其中，goroutine 是 Go 语言并发的基本单元，OS 线程负责执行 goroutine，processor 负责调度和管理线程和 goroutine 的执行。
> * GMP 调度模型的主要特点有：
>   * 多个 goroutine 映射到少量的 OS 线程，避免了线程上下文切换的开销。
>   * 多个 goroutine 共享一个线程的执行时间，这种共享方式可以避免线程创建和销毁的开销
>   * 调度器会动态地将 goroutine 映射到线程上，并根据系统的负载情况来调整线程的数量和 goroutine 的执行顺序。
>   * 支持并发垃圾回收：GMP 调度模型支持并发垃圾回收，这意味着垃圾回收器可以与应用程序同时运行，不会阻塞应用程序的执行。
>
> * 原理版：  
https://i6448038.github.io/2017/12/04/golang-concurrency-principle/
------------------------------------------------------------
# 8.GMP模型为什么一定要P
> 背诵版：  
> * 从M的数量维度去思考：
>   * 本地队列变多：由于M的数量一般是大于P的，如果将本地队列放在M上，会导致本地队列变得很多，这会导致协程的调度算法work stealing性能下降.
>   * 全局队列并发问题：如果没有P，当M要从全局队列里面获取G执行时，需要对全局队列加锁，在M数量较多时，会引起大量的锁竞争，导致性能下降。增加P之后，全局队列仍然存在，但是功能被弱化了，每次获取G，都是优先从本地队列中获取，如果都没有，再去全局队列获取
>
> 
> * 从设计的维度去思考，为什么不把P的逻辑放在M：
>   * 主要还是因为 M 其实是内核线程，内核只知道自己在跑线程，而 golang 的运行时（包括调度，垃圾回收等）其实都是用户空间里的逻辑。操作系统内核哪里还知道，也不需要知道用户空间的 golang 应用原来还有那么多花花肠子。这一切逻辑交给应用层自己去做就好，毕竟改内核线程的逻辑也不合适啊。
> * 本地队列：  
>   * P优先从本地队列获取goroutine执行，这比在全局队列中查找要高效得多（个人理解这一点不是P必要存在的因素，因为M也能做到这一点）
>
> 
> * 原理版：  
    https://juejin.cn/post/6968311281220583454
    https://learnku.com/articles/56813
------------------------------------------------------------
# 9.Panic&Recover的实现原理（Todo）
> d栈p队，遇p d先行，遇r p置空  
> * d栈p队： defer是栈，先进后出，panic是队列，先进先出（递归打印，链表尾先打印）
> * 遇p d先行：遇到panic，立马开始执行defer栈 
> * 遇r p置空：遇到recover，立马将panic队列置空，并返回对头信息，作为recover函数的返回值
![panic.png](images/panic.png)
------------------------------------------------------------
# 10.Defer实现原理(Todo)
------------------------------------------------------------
# 11.Channel的实现原理以及CSP并发模型
> 关关关空， 写关读0 （三种panic，一种读取0值）
> * 关关：关闭已经closed的channel，会panic
> * 关空：关闭一个nil的channel，会panic
> * 写关：向一个已经closed的channel写，会panic
> * 读0 ：从一个已经关闭的channel中读数据，特别注意如果channel中还有值，是能读取到正确的值的，如果channel中没有值了，就只能读取类型0值)
> 
> 
> * 底层实现原理：  
https://cloud.tencent.com/developer/article/1750350
------------------------------------------------------------
# 12.Interface的实现原理
-----------------------------------------------------------
# 13.反射的实现原理
------------------------------------------------------------
# 14.内存逃逸分析
------------------------------------------------------------
# 15.sync包的部分结构体实现
-----------------------------------------------------------
# 16.垃圾回收机制(GC)
> https://geektutu.com/post/qa-golang-2.html#Q5-%E7%AE%80%E8%BF%B0-Go-%E8%AF%AD%E8%A8%80GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86
------------------------------------------------------------
# 17.Contenx的实现
------------------------------------------------------------
# 18.switch...case需要注意的地方
-----------------------------------------------------------
# 19.内存对齐
> https://geektutu.com/post/hpg-struct-alignment.htm
------------------------------------------------------------
# 其它的花里胡哨
```
1. 空struct{}不占用任何存储空间。
   可用在map结构只需要key不需要value的场景下，将value设置为空struct{}
2. 有时两个nil值会不相等
3. make和new的区别
   new 它只接受一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针。同时请注意它同时把分配的内存置为零，也就是类型的零值。
   make也是用于内存分配的，但是和new不同，它只用于chan、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。
   注意，因为这三种类型是引用类型，所以必须得初始化，但是不是置为零值，这个和new是不一样的。
4. main和init函数的区别
   Go里面有两个保留的函数：init函数和main函数。下边就来比较一下两个函数的异同。
   相同点：两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。
   不同点：init可以应用于任意包中，且可以重复定义多个。main函数只能用于main包中，且只能定义一个。
   两个函数的执行顺序：
   对同一个go文件的init()调用顺序是从上到下的
   对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数
   对不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init()
   如果package存在依赖，则先调用最早被依赖的package中的init()
   最后调用main函数
   golang 面试题(从基础到高级)
   https://www.cnblogs.com/wpgraceii/p/10528183.html

怎样预防和定位协程泄漏
channel 的close
使用有缓存的channel限制协程数量
利用协程池（tunny）
监控协程数量（runtime.NumGoroutine()）
http://localhost:8899/debug/pprof/goroutine?debug=1 看到整个程序协程列表
http://localhost:8899/debug/pprof/goroutine?debug=2 可以通过协程后面的标签,看到当前协程的不同状态
泄露的原因大多集中在：
Goroutine 内正在进行 channel/mutex 等读写操作，但由于逻辑问题，某些情况下会被一直阻塞。
Goroutine 内的业务逻辑进入死循环，资源一直无法释放。
Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待。
go struct能不能比较？
可比较：Integer，Floating-point，String，Boolean，Complex(复数型)，Pointer，Channel，Interface，Array
不可比较：Slice，Map，Function
所以struct中一旦包含了Slice，Map，Function，就不能直接用”==“比较了，否则可以直接用“==”进行比较
不同类型的struct不能直接用“==”进行比较，编译期报错
go提供了一个函数reflect.DeepEqual(), 可以对任意两个struct进行深度比较
go struct能不能作为map的key？
只有可比较的struct才能作为map的key，否则在编译期报错
go env -w GO111MODULE=on 打开
go env -w GO111MODULE=off 关闭
golangci-lint run
```
